## Neural Network Regression Exercise ##import numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport tensorflow as tfprint('\ntensorflow: ', tf.__version__)## Importing the datasetdf = pd.read_csv('../data/insurance.csv')X = df.drop('charges', axis=1)y = df['charges']## Encoding some of the featuresfrom sklearn.compose import ColumnTransformerfrom sklearn.preprocessing import MinMaxScaler, OneHotEncoderct = ColumnTransformer(    transformers=[('one_hot_encoder', OneHotEncoder(handle_unknown='ignore'), ['sex', 'smoker', 'region']),                   ('min_max_scaler', MinMaxScaler(), ['age', 'bmi', 'children'])],     remainder='passthrough')X = ct.fit_transform(X)## Splitting the dataset into training set and test setfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y,                                                     test_size=.2,                                                     random_state=42)print('\nX_train size: {0} ({1}%)\n{2}'.format(X_train.shape[0],                                               (X_train.shape[0] / X.shape[0] * 100),                                               X_train[:10]))print('\nX_test size: {0} ({1}%)\n{2}'.format(X_test.shape[0],                                            (X_test.shape[0] / X.shape[0] * 100),                                            X_test[:10]))print('\ny_train size: {0} ({1}%)\n{2}'.format(y_train.shape[0],                                             (y_train.shape[0] / y.shape[0] * 100),                                             y_train.iloc[:10]))print('\ny_test size: {0} ({1}%)\n{2}'.format(y_test.shape[0],                                            (y_test.shape[0] / y.shape[0] * 100),                                            y_test.iloc[:10]))# ## Feature Scaling# from sklearn.preprocessing import StandardScaler# sc = StandardScaler()# y_train = sc.fit_transform(tf.expand_dims(y_train, axis=-1))# y_test = sc.transform(tf.expand_dims(y_test, axis=-1))## Building the ANNfrom tensorflow.keras import Sequential, layers, optimizers, lossestf.random.set_seed(42)# Creating the modelann_model = Sequential(name='exercise_model')# Adding hidden layersann_model.add(layers.Dense(100, activation='relu', name='input_layer'))ann_model.add(layers.Dense(100, activation='relu', name='hidden_layer_1'))ann_model.add(layers.Dense(1, name='output_layer'))# Compiling the modelann_model.compile(optimizer=optimizers.Adam(lr=.01), loss=losses.mae, metrics=['mae'])# Fitting the modelann_model.fit(X_train, y_train, epochs=100)## Predicting resulty_pred = ann_model.predict(X_test)# Comparing with the gorund truthprint('\nann_model predictions: \n',       np.concatenate((y_pred[:10], np.expand_dims(y_test.iloc[:10], axis=-1)), axis=1))## Evaluate the modelfrom tensorflow.keras.metrics import mean_absolute_error as maefrom tensorflow.keras.metrics import mean_squared_error as mseprint('\nEvaluate {0} on the test set.'.format(ann_model.name))ann_model.evaluate(X_test, y_test)print('\nMean Absolute Error evaluation: \n', mae([y_test.iloc[4]], [y_pred[4]]))print('\nMean Squared Error evaluation: \n', mse([y_test.iloc[11]], [y_pred[11]]))print('\ny_train median: {0} \ny_train mean {1}'.format(np.median(y_train), np.mean(y_train)))